#pragma kernel ClearPartitioningCells
#pragma kernel FillPartitioningCells
#pragma kernel FindNeighbours
#pragma kernel CalculateViscosity
#pragma kernel ApplyViscosity
#pragma kernel ApplyVelocity
#pragma kernel CalculateDensityDisplacement
#pragma kernel ApplyDensityDisplacement

struct Particle
{
    int id;
    float2 Position;
    float2 PreviousPosition;
    float2 Velocity;
    float2 Change;
    int typeNumber;
    float4 Color;
};


// Settings
int _NumParticles;
int _MaxNumParticles;
int _MaxNumNeighbours;
float _AreaMinX;
float _AreaMinY;
float _AreaMaxX;
float _AreaMaxY;
int _MaxNumParticlesPerCell;
float _InteractionRadius;


// Adjusted per frame
float _Time;



RWStructuredBuffer<Particle> _Particles; //Length: MaxNumParticles

// Number of cells: ceil((AreaMaxX - AreaMinX) / InteractionRadius) * ceil((AreaMaxY - AreaMinY) / InteractionRadius)
RWStructuredBuffer<int> _CellParticleCount; // Length: Number of cells
RWStructuredBuffer<int> _ParticlesInCells; //Length:  Number of cells * MaxNumParticlesPerCell
RWStructuredBuffer<int> _ParticleNeighbours; //Length: MaxNumParticles * MaxNumNeighbours
RWStructuredBuffer<int> _ParticleNeighbourCount; //Length: MaxNumParticles 
RWStructuredBuffer<float2> _ChangeBuffer; //Length: MaxNumParticles * MaxNumNeighbours




int2 CellCoordinates(in float2 position)
{
    int2 result;
    result.x = floor((position.x-_AreaMinX)/_InteractionRadius);
    result.y = floor((position.y-_AreaMinY)/_InteractionRadius);
    return result;
}

int CellIndex(in float2 position)
{
    if (position.x < _AreaMinX || position.x > _AreaMaxX || 
    position.y < _AreaMinY || position.y > _AreaMaxY)
    {
        return -1;
    }

    int2 coords = CellCoordinates(position);
    return coords.x + coords.y * ceil((_AreaMaxX-_AreaMinX)/_InteractionRadius);
    
}



float rand(in float2 uv)
{
    return (frac(sin(dot(uv, float2(12.9898, 78.233) * 2.0)) * 43758.5453)) * 2 - 1;
}

int numCells()
{
    return ceil((_AreaMaxX-_AreaMinX)/_InteractionRadius) *
        ceil((_AreaMaxY-_AreaMinY)/_InteractionRadius);
}

/*
 *int indexFromId(uint3 id)
{
    return id.x + _CubesPerAxis * (id.y + _CubesPerAxis * id.z);
}
*/

//TODO: Threadien lkm j채rkev채ksi
[numthreads(8,8,1)]
void ClearPartitioningCells (uint3 id : SV_DispatchThreadID)
{
    int index = id.x * 128 + id.y;
    if (index >= numCells()) return;
    _CellParticleCount[index] = 0;
}

//TODO: Threadien lkm j채rkev채ksi
[numthreads(8,8,1)]
void FillPartitioningCells (uint3 id : SV_DispatchThreadID)
{
    const int index = id.x * 128 + id.y;
    if (index >= _NumParticles) return;

    const int cellIndex = CellIndex(_Particles[index].Position);

    if (cellIndex==-1) return;
  
    
    int previousCount = 0;
    InterlockedAdd(_CellParticleCount[cellIndex], 1, previousCount);
    if (previousCount >= _MaxNumParticlesPerCell)
    {
        return;
    }
  
    _ParticlesInCells[cellIndex * _MaxNumParticlesPerCell + previousCount] = index;

}

[numthreads(8,8,1)]
void FindNeighbours (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;
    
    int count = 0;
   
    for (int x=-1; x<=1; x++)
    {
        for (int y=-1; y<=1; y++)
        {
            int cellIndex = CellIndex(_Particles[particleIndex].Position + float2(x*_InteractionRadius, y*_InteractionRadius));
            if (cellIndex == -1) continue;

            for (int i=0; i<_CellParticleCount[cellIndex]; i++)
            {
                if (i==_MaxNumParticlesPerCell) break;

                int otherParticleIndex = _ParticlesInCells[cellIndex * _MaxNumParticlesPerCell + i];
                if (otherParticleIndex == particleIndex) continue;
                if (length(_Particles[particleIndex].Position - _Particles[otherParticleIndex].Position) < _InteractionRadius)
                {
                    _ParticleNeighbours[particleIndex * _MaxNumNeighbours + count] = otherParticleIndex;
                    count = count + 1;
                }
            }
        }
    }

    _ParticleNeighbourCount[particleIndex] = count;
}


// Record change to particle with index1 that is caused by particle with index2
void RecordChange(float2 change, int index1, int index2)
{
    for (int i=0; i<_ParticleNeighbourCount[index1]; i++)
    {
        if (_ParticleNeighbours[index1 * _MaxNumNeighbours + i] == index2)
        {
            _ChangeBuffer[index1 * _MaxNumNeighbours + i] = change;
            return;
        }
    }
}

float2 ViscosityImpulse(int particle1, int particle2)
{
    //   if (_Particles[neighbourIndex].typeNumber == 1) continue;
    const float sigma = 0.05;
    const float beta = 0.05;

    float q = length(_Particles[particle1].Position - _Particles[particle2].Position) / _InteractionRadius;
    if (q >= 1) return float2(0,0);
    float2 r = normalize(_Particles[particle1].Position - _Particles[particle2].Position);
    float u = dot(_Particles[particle1].Velocity - _Particles[particle2].Velocity, r);
    if (u <= 0) return float2(0,0);
    return _Time * (1 - q) * (sigma * u + beta * u * u) * r;
}


[numthreads(8,8,1)]
void CalculateViscosity (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;

    _Particles[particleIndex].Change = float2(0,0);
    
    for (int i=0; i<_ParticleNeighbourCount[particleIndex]; i++)
    {
        int neighbourIndex = _ParticleNeighbours[particleIndex * _MaxNumNeighbours + i];
        float2 impulse = ViscosityImpulse(particleIndex, neighbourIndex);
        _Particles[particleIndex].Change += -impulse * 0.5;
   }
}



[numthreads(8,8,1)]
void ApplyViscosity (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;

    _Particles[particleIndex].Velocity += _Particles[particleIndex].Change;
/*
    for (int i=0; i<_ParticleNeighbourCount[particleIndex]; i++)
    {
        _Particles[particleIndex].Velocity += _ChangeBuffer[particleIndex * _MaxNumNeighbours + i];
    }*/
}

[numthreads(8,8,1)]
void ApplyVelocity (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;

    _Particles[particleIndex].PreviousPosition = _Particles[particleIndex].Position;
    _Particles[particleIndex].Position += _Particles[particleIndex].Velocity * _Time;

}


[numthreads(8,8,1)]
void CalculateDensityDisplacement (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;

    const float restDensity = 5;
    const float stiffness = 750;
    const float nearStiffness = 1500;
    
    _Particles[particleIndex].Change = float2(0,0);
    float density = 0;
    float nearDensity = 0;
     
    
    for (int i=0; i<_ParticleNeighbourCount[particleIndex]; i++)
    {
        int neighbourIndex = _ParticleNeighbours[particleIndex * _MaxNumNeighbours + i];
        float q = length(_Particles[particleIndex].Position - _Particles[neighbourIndex].Position) / _InteractionRadius;
        if (q<1)
        {
            density += (1-q)*(1-q);
            nearDensity += (1-q)*(1-q)*(1-q);
        }

        RecordChange(float2(0,0),neighbourIndex,particleIndex);
    }

    float pressure = stiffness * (density - restDensity);
    float nearPressure = nearStiffness * nearDensity;

    for (int j=0; j<_ParticleNeighbourCount[particleIndex]; j++)
    {
        int neighbourIndex = _ParticleNeighbours[particleIndex * _MaxNumNeighbours + j];
        float q = length(_Particles[particleIndex].Position - _Particles[neighbourIndex].Position) / _InteractionRadius;

        if (q < 1)
        {
            float2 d = _Time * _Time * (pressure * (1 - q) + nearPressure * (1 - q) * (1 - q)) *
                        normalize(_Particles[particleIndex].Position - _Particles[neighbourIndex].Position);
            _Particles[particleIndex].Change -= 0.5 * d;
            RecordChange(0.5 * d, neighbourIndex, particleIndex);
        }
      
    }
    
}

[numthreads(8,8,1)]
void ApplyDensityDisplacement (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;
    _Particles[particleIndex].Position += _Particles[particleIndex].Change;

    for (int i=0; i<_ParticleNeighbourCount[particleIndex]; i++)
    {
        _Particles[particleIndex].Position += _ChangeBuffer[particleIndex * _MaxNumNeighbours + i];
    }
}



/*
 private void MaintainDensity(IParticleData particleData,  float timeStep)
        {
             var particles = particleData.All();
            
            for (int i=0; i<particles.Length; i++)
            {
                if (particles[i].Type == ParticleType.Solid) continue;
                
                float density = 0f;
                float nearDensity = 0f;
                
                var neighbours = particleData.NeighbourIndices(i);
                
                foreach (int j in neighbours)
                {
                    float distance = (particles[i].Position - particles[j].Position).magnitude;
                    float q = distance / _settings.InteractionRadius;
                    if (q < 1f)
                    {
                        density += Pow2(1f - q);
                        nearDensity += Pow3(1f - q);
                    }
                }

                float pressure = _settings.Stiffness * (density - _settings.RestDensity);
                float nearPressure = _settings.NearStiffness * nearDensity;
                Vector2 displacement = Vector2.zero;

                foreach (int j in neighbours)
                {
                    if (particles[j].Type == ParticleType.Solid) continue;

                    float distance = (particles[i].Position - particles[j].Position).magnitude;
                    float q = distance / _settings.InteractionRadius;
                    if (q < 1f)
                    {
                        Vector2 d = Pow2(timeStep) * (pressure * (1f - q) + nearPressure * Pow2(1f - q)) *
                                    (particles[j].Position - particles[i].Position).normalized;
                        
                        
                        if (particles[j].Type == ParticleType.Liquid)
                            particles[j].Position += 0.5f * d;
                        displacement -= 0.5f * d;
                    }
                }
      
                particles[i].Position += displacement;
        

     
            }
   
            
          
         
        }
        */
        


