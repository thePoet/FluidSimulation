// Compute shader for particle based fluid dynamics.
// Based on paper by Simon Clavet, Philippe Beaudoin, and Pierre Poulin
// https://www.academia.edu/452554/Particle-Based_Viscoelastic_Fluid_Simulation

#pragma kernel ApplyGravity
#pragma kernel ClearPartitioningCells
#pragma kernel FillPartitioningCells
#pragma kernel FindNeighbours
#pragma kernel CalculateViscosity
#pragma kernel ApplyViscosity
#pragma kernel ApplyVelocity
#pragma kernel CalculatePressures
#pragma kernel CalculateDensityDisplacement
#pragma kernel ApplyDensityDisplacement
#pragma kernel ConfineParticlesToArea

struct Particle
{
    int id;
    float2 Position;
    float2 PreviousPosition;
    float2 Velocity;
    int typeNumber;
};

struct TempParticleData
{
    float2 PositionChange;
    float2 VelocityChange;
    float2 PreviousPosition;
    float Pressure;
    float NearPressure;
};


// Settings
int _NumParticles;
int _MaxNumParticles;
int _MaxNumNeighbours;
int _MaxNumParticlesPerCell;
float _InteractionRadius;
float _Gravity;

float _AreaMinX;
float _AreaMinY;
float _AreaMaxX;
float _AreaMaxY;



// Adjusted per frame
float _DeltaTime;



RWStructuredBuffer<Particle> _Particles; //Length: MaxNumParticles
RWStructuredBuffer<TempParticleData> _TempParticleData; 
// Number of cells: ceil((AreaMaxX - AreaMinX) / InteractionRadius) * ceil((AreaMaxY - AreaMinY) / InteractionRadius)
RWStructuredBuffer<int> _CellParticleCount; // Length: Number of cells
RWStructuredBuffer<int> _ParticlesInCells; //Length:  Number of cells * MaxNumParticlesPerCell
RWStructuredBuffer<int> _ParticleNeighbours; //Length: MaxNumParticles * MaxNumNeighbours
RWStructuredBuffer<int> _ParticleNeighbourCount; //Length: MaxNumParticles 
//RWStructuredBuffer<float2> _ChangeBuffer; //Length: MaxNumParticles * MaxNumNeighbours
RWStructuredBuffer<float> _Stats; //Length: 10 

// --------------------- UTILITY FUNCTIONS ---------------------

float cross2d(float2 a, float2 b)
{
    return a.x * b.y - a.y * b.x;
}

 bool IntersectLineSegments2D(float2 p1start, float2 p1end, float2 p2start, float2 p2end, out float2 intersection)
{
        float2 p = p1start;
        float2 r = p1end - p1start;
        float2 q = p2start;
        float2 s = p2end - p2start;
        float2 qminusp = q - p;

        if (abs(cross2d(r,s)) < 0.000001)
        {
            // Parallel lines
            if (abs(cross2d(qminusp, r)) < 0.000001)
            {
                // Co-linear lines, could overlap
                float rdotr = dot(r, r);
                float sdotr = dot(s, r);
                // this means lines are co-linear
                // they may or may not be overlapping
                float t0 = dot(qminusp, r / rdotr);
                float t1 = t0 + sdotr / rdotr;
                if (sdotr < 0)
                {
                    // lines were facing in different directions so t1 > t0, swap to simplify check
                    float temp = t0;
                    t0 = t1;
                    t1 = temp;
                }
                if (t0 <= 1 && t1 >= 0)
                {
                    // Nice half-way point intersection
                    float t = lerp(max(0, t0), min(1, t1), 0.5f);
                    intersection = p + t * r;
                    return true;
                } 
                // Co-linear but disjoint
                intersection = float2(0,0);
                return false;
            } 
            // Just parallel in different places, cannot intersect
            intersection = float2(0,0);
            return false;
        }
        // Not parallel, calculate t and u
        float t = cross2d(qminusp, s) / cross2d(r, s);
        float u = cross2d(qminusp, r) / cross2d(r, s);
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1)
        {
            intersection = p + t * r;
            return true;
        }
        // Lines only cross outside segment range
        intersection = float2(0, 0);
        return false;
}

// ------------------------------------------------------------


int2 CellCoordinates(in float2 position)
{
    int2 result;
    result.x = floor((position.x-_AreaMinX)/_InteractionRadius);
    result.y = floor((position.y-_AreaMinY)/_InteractionRadius);
    return result;
}

int CellIndex(in float2 position)
{
    if (position.x < _AreaMinX || position.x > _AreaMaxX || 
    position.y < _AreaMinY || position.y > _AreaMaxY)
    {
        return -1;
    }

    int2 coords = CellCoordinates(position);
    return coords.x + coords.y * ceil((_AreaMaxX-_AreaMinX)/_InteractionRadius);
    
}

bool IsInsideArea(float2 position)
{
    return position.x >= _AreaMinX && position.x <= _AreaMaxX && position.y >= _AreaMinY && position.y <= _AreaMaxY;
}



int numCells()
{
    return ceil((_AreaMaxX-_AreaMinX)/_InteractionRadius) *
        ceil((_AreaMaxY-_AreaMinY)/_InteractionRadius);
}



[numthreads(8,8,1)]
void ApplyGravity (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;

    _Particles[particleIndex].Velocity += float2(0.0, -_DeltaTime * _Gravity);
}


[numthreads(8,8,1)]
void ClearPartitioningCells (uint3 id : SV_DispatchThreadID)
{
    int index = id.x * 128 + id.y;
    if (index >= numCells()) return;
    _CellParticleCount[index] = 0;

    if (index==0)
    {
        for (int i=0; i<10; i++)
            _Stats[i] = 0;
    }
}


[numthreads(8,8,1)]
void FillPartitioningCells (uint3 id : SV_DispatchThreadID)
{
    const int index = id.x * 128 + id.y;
    if (index >= _NumParticles) return;

    const int cellIndex = CellIndex(_Particles[index].Position);

    if (cellIndex==-1)
    {
        _Stats[1] += 1;
        _Stats[8] = _Particles[index].Position.x;
        _Stats[9] = _Particles[index].Position.y;
        
     //   _Particles[index].Color = float4(1,0,0,1);
        return;
    }
  

    //TODO: Maybe faster without interlocked by doing cell per thread?
    int previousCount = 0;
    InterlockedAdd(_CellParticleCount[cellIndex], 1, previousCount);
    if (previousCount >= _MaxNumParticlesPerCell)
    {
        _Stats[0] += 1;
        return;
    }

  //  if (cellIndex%2==0)  _Particles[index].Color = float4(1,1,0,1);
    //if (cellIndex%2==1)  _Particles[index].Color = float4(1,0,1,1);
  
    _ParticlesInCells[cellIndex * _MaxNumParticlesPerCell + previousCount] = index;

}

[numthreads(8,8,1)]
void FindNeighbours (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;
    
    int count = 0;
   
    for (int x=-1; x<=1; x++)
    {
        for (int y=-1; y<=1; y++)
        {
            int cellIndex = CellIndex(_Particles[particleIndex].Position + float2(x*_InteractionRadius, y*_InteractionRadius));
            if (cellIndex == -1) continue;

            for (int i=0; i<_CellParticleCount[cellIndex]; i++)
            {
                if (i==_MaxNumParticlesPerCell) break;

                int otherParticleIndex = _ParticlesInCells[cellIndex * _MaxNumParticlesPerCell + i];
                if (otherParticleIndex == particleIndex) continue;
                if (length(_Particles[particleIndex].Position - _Particles[otherParticleIndex].Position) < _InteractionRadius)
                {
                    _ParticleNeighbours[particleIndex * _MaxNumNeighbours + count] = otherParticleIndex;
                    count = count + 1;
                }
            }
        }
    }

    _ParticleNeighbourCount[particleIndex] = count;
}


float2 ViscosityImpulse(int particle1, int particle2)
{
    //   if (_Particles[neighbourIndex].typeNumber == 1) continue;
    const float sigma = 0.02;
    const float beta = 0.02;

    float distance = length(_Particles[particle1].Position - _Particles[particle2].Position);

    // Is there a better way? Add epsilon to position?
    if (distance < 0.00001) return float2(0,0);
    
    float q = distance / _InteractionRadius;
    if (q >= 1) return float2(0,0);
    float2 r = normalize(_Particles[particle1].Position - _Particles[particle2].Position);
    
    float u = dot(_Particles[particle1].Velocity - _Particles[particle2].Velocity, r);
    if (u <= 0) return float2(0,0);
    return _DeltaTime * (1 - q) * (sigma * u + beta * u * u) * r;
}


[numthreads(8,8,1)]
void CalculateViscosity (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;

    _TempParticleData[particleIndex].VelocityChange = float2(0,0);
    
    for (int i=0; i<_ParticleNeighbourCount[particleIndex]; i++)
    {
        int neighbourIndex = _ParticleNeighbours[particleIndex * _MaxNumNeighbours + i];
        float2 impulse = ViscosityImpulse(particleIndex, neighbourIndex);
        _TempParticleData[particleIndex].VelocityChange += -impulse * 0.5;
   }
}



[numthreads(8,8,1)]
void ApplyViscosity (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;
    _Particles[particleIndex].Velocity += _TempParticleData[particleIndex].VelocityChange;
}

[numthreads(8,8,1)]
void ApplyVelocity (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;

    _Particles[particleIndex].PreviousPosition = _Particles[particleIndex].Position;
    _Particles[particleIndex].Position += _Particles[particleIndex].Velocity * _DeltaTime;

}

[numthreads(8,8,1)]
void CalculatePressures (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;

    const float restDensity = 5;
    const float stiffness = 750;
    const float nearStiffness = 1500;

    float density = 0;
    float nearDensity = 0;
    
    for (int i=0; i<_ParticleNeighbourCount[particleIndex]; i++)
    {
        int neighbourIndex = _ParticleNeighbours[particleIndex * _MaxNumNeighbours + i];
        float q = length(_Particles[particleIndex].Position - _Particles[neighbourIndex].Position) / _InteractionRadius;
        if (q<1)
        {
            density += (1-q)*(1-q);
            nearDensity += (1-q)*(1-q)*(1-q);
        }
    }
    _TempParticleData[particleIndex].Pressure = stiffness * (density - restDensity);
    _TempParticleData[particleIndex].NearPressure = nearStiffness * nearDensity;
}

float2 DensityDisplacement(int particle1, int particle2)
{
    float q = length(_Particles[particle1].Position - _Particles[particle2].Position) / _InteractionRadius;

    if (q>=1) return float2(0.0,0.0);

    
    float pressure = _TempParticleData[particle1].Pressure;
    float nearPressure = _TempParticleData[particle1].NearPressure;

    float2 fromTo = _Particles[particle2].Position - _Particles[particle1].Position;

    // Is there a better way? Add epsilon to position?
    if (length(fromTo) < 0.000001) return float2(0,0); 

    
    float2 d = _DeltaTime * _DeltaTime * (pressure * (1 - q) + nearPressure * (1 - q) * (1 - q)) *
                normalize(fromTo);
    
    return 0.5 * d;
}


[numthreads(8,8,1)]
void CalculateDensityDisplacement (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;

    _TempParticleData[particleIndex].PositionChange = float2(0,0);

    for (int j=0; j<_ParticleNeighbourCount[particleIndex]; j++)
    {
        int neighbourIndex = _ParticleNeighbours[particleIndex * _MaxNumNeighbours + j];
        
        _TempParticleData[particleIndex].PositionChange -= DensityDisplacement(particleIndex, neighbourIndex);
        _TempParticleData[particleIndex].PositionChange += DensityDisplacement(neighbourIndex, particleIndex);
    }
    
}

[numthreads(8,8,1)]
void ApplyDensityDisplacement (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x * 128 + id.y;
    if (particleIndex >= _NumParticles) return;
    _Particles[particleIndex].Position += _TempParticleData[particleIndex].PositionChange;
}



// ---------------------- ENFORCING BOUNDARIES ----------------------



bool BoxLineIntersection(float2 minCorner, float2 maxCorner, float2 start, float2 end, out float2 intersection, out float2 normal)
{
    intersection = float2(0,0);
    normal = float2(0,0);

    if (IntersectLineSegments2D(start, end, float2(minCorner.x, minCorner.y), float2(maxCorner.x, minCorner.y), intersection))
    {
        normal = float2(0, 1);
        return true;
    }
    if (IntersectLineSegments2D(start, end, float2(minCorner.x, maxCorner.y), float2(maxCorner.x, maxCorner.y), intersection))
    {
        normal = float2(0, -1);
        return true;
    }
    if (IntersectLineSegments2D(start, end, float2(minCorner.x, minCorner.y), float2(minCorner.x, maxCorner.y), intersection))
    {
        normal = float2(1, 0);
        return true;
    }
    if (IntersectLineSegments2D(start, end, float2(maxCorner.x, minCorner.y), float2(maxCorner.x, maxCorner.y), intersection))
    {
        normal = float2(-1, 0);
        return true;
    }
    return false;
}

bool IsInsideBox(float2 position, float2 minCorner, float2 maxCorner)
{
    return position.x >= minCorner.x && position.x <= maxCorner.x &&
        position.y >= minCorner.y && position.y <= maxCorner.y;
}

float2 ClampToBox(float2 position, float2 minCorner, float2 maxCorner)
{
    if (position.x < minCorner.x) position.x = minCorner.x;
    if (position.x > maxCorner.x) position.x = maxCorner.x;
    if (position.y < minCorner.y) position.y = minCorner.y;
    if (position.y > maxCorner.y) position.y = maxCorner.y;
    return position;
}

[numthreads(8,8,1)]
void ConfineParticlesToArea (uint3 id : SV_DispatchThreadID)
{
    int i = id.x * 128 + id.y;
    if (i >= _NumParticles) return;

    float margin = 20;
    float2 minCorner = float2(_AreaMinX + margin, _AreaMinY + margin);
    float2 maxCorner = float2(_AreaMaxX - margin, _AreaMaxY - margin);

    if (IsInsideBox(_Particles[i].Position, minCorner, maxCorner)) return;

    
    float2 intersection;
    float2 normal;
    BoxLineIntersection(minCorner, maxCorner, _Particles[i].PreviousPosition, _Particles[i].Position, intersection, normal);

    float2 velocity = _Particles[i].Position - _Particles[i].PreviousPosition;
    float2 velocityNormal = dot(velocity, normal) * normal;
    float2 velocityTangent = velocity - velocityNormal;

    float tangentialFriction = 0.5f;
            
    float2 impulse = -velocityNormal - tangentialFriction * velocityTangent;
            
    float2 endPosition = _Particles[i].Position + impulse;

    if (!IsInsideBox(endPosition, minCorner, maxCorner))
    {
        endPosition = ClampToBox(endPosition, minCorner, maxCorner);
    }
 
            
    _Particles[i].Position = endPosition;


}


